<?php
/**
 * Hyvä Themes - https://hyva.io
 * Copyright © Hyvä Themes 2022-present. All rights reserved.
 * This product is licensed per Magento install
 * See https://hyva.io/license
 */

declare(strict_types=1);

use Hyva\Theme\Model\ViewModelRegistry;
use Hyva\Theme\ViewModel\HyvaCsp;
use Magento\Framework\Escaper;
use Magento\Framework\View\Element\Template;

/**
 * These variables are automatically assigned to any template
 *
 * @var Template $block
 * @var Escaper $escaper
 * @var ViewModelRegistry $viewModels
 * @var HyvaCsp $hyvaCsp
 */

/** @var \StripeIntegration\Payments\Block\Button $block */
/** @var \Hyva\CheckoutStripe\Magewire\View\PaymentRequestButton $magewire */
?>

<?php if ($block->isEnabled('minicart') && isset($magewire)): ?>
    <script>
        <?php
        /**
         * There are a few elements in play in this script:
         * - Alpine (The call to init)
         * - The Stripe SDK (The call from loadStripe to initPaymentRequest)
         * - The Stripe Elements button (The click handler initiates the quote)
         * - The Stripe Payment Request (Updates the quote with address and shipping information)
         * - The Magewire component (identified by `const component`, communicates with the backend)
         *
         * Any calls to and from the `component` variable are Magewire calls. These send and retrieve data from the
         * backend.
         *
         * @see \Hyva\CheckoutStripe\Magewire\View\PaymentRequestButton for the backend of this.
         */
        ?>
        function initStripePaymentRequestButtonMinicart() {
            const component = Magewire.find('stripe.paymentrequest.minicart');
            let StripeJs, expressCheckoutElement;

            return {
                isLoading: false,
                initMinicartButton() {
                    component.loadSettings('minicart').then(() => {
                        if (component.isEmptyCart) {
                            // Cart is empty, don't continue
                            return;
                        }

                        this.loadStripe()
                    });

                    window.addEventListener(
                        'stripe-authenticate-customer',
                        event => this.authenticateCustomer(event)
                    );
                },

                loadStripe() {
                    if (typeof window.Stripe === 'undefined') {
                        window.loadStripe(() => this.initPaymentRequest());
                    } else {
                        this.initPaymentRequest();
                    }
                },

                initPaymentRequest() {

                    if (expressCheckoutElement) { expressCheckoutElement.destroy(); }

                    StripeJs = Stripe(component.walletParams.apiKey, component.walletParams.options);

                    const elements = StripeJs.elements(component.eceParams.elementOptions);
                    expressCheckoutElement = elements.create('expressCheckout', <?= $block->getButtonConfig(); ?>);

                    const element = document.getElementById('stripe-minicart-button');
                    element.classList.add('payment-request-button');
                    element.classList.add('cart');
                    expressCheckoutElement.mount(element);

                    expressCheckoutElement.on('click', (event) => {
                        this.isLoading = true;
                        event.resolve(component.resolvePayload);
                    });

                    expressCheckoutElement.on('shippingaddresschange', event => {
                        const address = event.address
                        // For some countries like Japan, the ECE does not set the City, only the region
                        if (address.city.length === 0 && address.region.length > 0) {
                            address.city = address.region;
                        }
                        component.estimateCart(event.address).then(
                            () => {
                                const amount = window.stripeUtils.addLineItemsAmounts(component.resolvePayload.lineItems);
                                if (amount > 0) {
                                    elements.update({ amount: amount });
                                }
                                const resolveObject = {
                                    shippingRates: component.resolvePayload.shippingRates,
                                    lineItems: component.resolvePayload.lineItems ?? []
                                };
                                event.resolve(resolveObject);
                            }
                        );
                    });

                    expressCheckoutElement.on('shippingratechange', event => {
                        const shippingMethod = event.shippingRate.hasOwnProperty('id')
                            ? event.shippingRate.id
                            : null;

                        component.updateShippingRate(shippingMethod).then(
                            () => {
                                const amount = window.stripeUtils.addLineItemsAmounts(component.resolvePayload.lineItems);
                                if (amount > 0) {
                                    elements.update({ amount: amount });
                                }
                                const resolveObject = {
                                    shippingRates: component.resolvePayload.shippingRates,
                                    lineItems: component.resolvePayload.lineItems
                                };
                                event.resolve(resolveObject);

                            }
                        );
                    });

                    expressCheckoutElement.on('cancel', (ev) => {
                        component.loadSettings('minicart').then(() => {
                            if (component.isEmptyCart) {
                                // Cart is empty, don't continue
                                return;
                            }

                            this.loadStripe()
                        });

                        this.isLoading = false;
                        window.dispatchEvent(new Event('reload-customer-section-data'));

                        return window.dispatchMessages && window.dispatchMessages([{
                            type: 'error',
                            text: '<?= $escaper->escapeJs(__('Express Checkout has been canceled.')); ?>'
                        }], 5000);
                    });

                    expressCheckoutElement.on('confirm', confirm => {
                        this.confirm = confirm;
                        elements.submit().then(() => {
                            const paymentMethodData = {
                                elements: elements,
                                params: {
                                    billing_details: confirm.billingDetails
                                },
                                shipping: confirm.shippingAddress
                            };

                            StripeJs.createConfirmationToken(paymentMethodData).then(result => {
                                confirm.confirmationToken = result.confirmationToken;

                                this.placeOrder(confirm);
                            });
                        });
                    });
                },

                placeOrder() {
                    this.isLoading = true;
                    component.placeOrder(
                        this.confirm,
                        'product'
                    ).then(() => {
                        if (component.placeOrderResult.redirect) {
                            window.location = component.placeOrderResult.redirect;
                            return;
                        }

                        if (component.placeOrderResult.error) {
                            this.isLoading = false;
                            window.dispatchMessages && window.dispatchMessages([{
                                type: 'error',
                                text: component.placeOrderResult.error
                            }], 5000);
                        }

                        if (component.orderPlaced) {
                            this.isLoading = false;
                        }
                    })
                },

                authenticateCustomer(event) {
                    const intentId = event.detail.clientSecret;
                    const handleIntent = result => {
                        const intent = result.paymentIntent || result.setupIntent;
                        const requiresActionStatuses = ['requires_action', 'requires_source_action'];

                        if (!requiresActionStatuses.includes(intent.status)) {
                            this.placeOrder();
                            return;
                        }

                        if (intent.next_action && intent.next_action.type === 'verify_with_microdeposits') {
                            window.location = intent.next_action.verify_with_microdeposits.hosted_verification_url;
                            return;
                        }

                        StripeJs.handleNextAction({
                            clientSecret: intent.client_secret
                        }).then(result => {
                            if (result.error) {
                                this.isLoading = false;

                                window.dispatchMessages && window.dispatchMessages([{
                                    type: 'error',
                                    text: result.error.message
                                }], 5000);

                                return;
                            }

                            this.placeOrder();
                        });
                    };

                    if (intentId.startsWith('pi_')) {
                        StripeJs.retrievePaymentIntent(intentId).then(handleIntent);
                        return;
                    }

                    if (intentId.startsWith('seti_')) {
                        StripeJs.retrieveSetupIntent(intentId).then(handleIntent);
                        return;
                    }

                    throw new Error("Invalid intent ID");
                }
            }
        }

        window.addEventListener(
            'alpine:init',
            () => Alpine.data('initStripePaymentRequestButtonMinicart', initStripePaymentRequestButtonMinicart),
            {once: true}
        )
    </script>
    <?php $hyvaCsp->registerInlineScript() ?>
<?php else: ?>
    <?php // Magewire requires an element to be returned. So, when this option is disabled, we return an empty div. ?>
    <div class="hidden"></div>
<?php endif; ?>
